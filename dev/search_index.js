var documenterSearchIndex = {"docs":
[{"location":"#HermiteGF.jl-Documentation-1","page":"Documentation","title":"HermiteGF.jl Documentation","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"Stable evaluation of Gaussian radial basis functions using Hermite polynomials","category":"page"},{"location":"#Types-1","page":"Documentation","title":"Types","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"Modules = [HermiteGF]\nOrder   = [:type]","category":"page"},{"location":"#HermiteGF.Chebyshev","page":"Documentation","title":"HermiteGF.Chebyshev","text":"Chebyshev( xmin, xmax, nx )\n\nChebyshev nodes\n\n\n\n\n\n","category":"type"},{"location":"#HermiteGF.Hermite","page":"Documentation","title":"HermiteGF.Hermite","text":"Hermite( nodes::NodesType, epsilon:Real, gamma:Real )\n\nHermite inteprolation\n\n\n\n\n\n","category":"type"},{"location":"#HermiteGF.Hermite-Tuple{Array{Float64,1}}","page":"Documentation","title":"HermiteGF.Hermite","text":"Hermite( xe )\n\nThis function returns the matrix He of the values of the HermiteGF basis functions. The computation is done via three term recurrence for Hermite functions with an argument gamma*x and then appropriate exponential scaling.\n\nMore details can be found in Section 5.1 of the paper\n\nSTABLE EVALUATION OF GAUSSIAN RADIAL BASIS  FUNCTIONS USING HERMITE POLYNOMIALS  by Anna Yurova and Katharina Kormann.\n\n\n\n\n\n","category":"method"},{"location":"#HermiteGF.Radial","page":"Documentation","title":"HermiteGF.Radial","text":"Radial( nodes::NodesType, epsilon, gamma )\n\nRadial interpolation\n\n\n\n\n\n","category":"type"},{"location":"#HermiteGF.Radial-Tuple{Array{Float64,1}}","page":"Documentation","title":"HermiteGF.Radial","text":"Radial( xe )\n\nreturns evaluated function\n\n\n\n\n\n","category":"method"},{"location":"#HermiteGF.Uniform","page":"Documentation","title":"HermiteGF.Uniform","text":"Uniform( xmin, xmax, nx )\n\nUniform nodes\n\n\n\n\n\n","category":"type"},{"location":"#HermiteGF.InterpolationType","page":"Documentation","title":"HermiteGF.InterpolationType","text":"Interpolation type (Hermite or Radial) \n\n\n\n\n\n","category":"type"},{"location":"#HermiteGF.NodesType","page":"Documentation","title":"HermiteGF.NodesType","text":"Node positions (Uniform or Chebyshev) \n\n\n\n\n\n","category":"type"},{"location":"functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"Modules = [HermiteGF]\nOrder   = [:function]","category":"page"},{"location":"functions/#HermiteGF.interpolate-Tuple{HermiteGF.InterpolationType,Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"HermiteGF.interpolate","text":" interpolate( interp :: InterpolationType, \n              f  :: Array{Float64,1},\n              xe :: Array{Float64,1})\n\nComputes interpolation of a 1D function via Hermite-tensor method.\n\nArguments:\n\ninterp : inteprolation type (Hermite or Radial)\nf      : 1d array containing values at interpolation nodes (Chebyshev or Uniform)\nxe     : vector of evaluation points \n\n© Anna Yurova, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#HermiteGF.interpolate-Tuple{HermiteGF.InterpolationType,HermiteGF.InterpolationType,Array{Float64,2},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"HermiteGF.interpolate","text":" interpolate( interp_x :: InterpolationType, \n              interp_y :: InterpolationType, \n              f  :: Array{Float64,2},\n              xe :: Array{Float64,1},\n              ye :: Array{Float64,1})\n\nComputes interpolation of a 2D function via Hermite-tensor method.\n\nArguments:\n\ninterp : inteprolation type (Hermite or Radial)\nf      : 2d array containing values at interpolation nodes (Chebyshev or Uniform)\nxe,ye  : vector of evaluation points \n\n\n\n\n\n","category":"method"},{"location":"functions/#HermiteGF.interpolate-Tuple{HermiteGF.InterpolationType,HermiteGF.InterpolationType,HermiteGF.InterpolationType,Array{Float64,3},Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"HermiteGF.interpolate","text":" interpolate( interp_x :: InterpolationType, \n              interp_y :: InterpolationType, \n              interp_z :: InterpolationType, \n              f  :: Array{Float64,3},\n              xe :: Array{Float64,1},\n              ye :: Array{Float64,1},\n              ze :: Array{Float64,1})\n\nComputes interpolation of a 3D function via Hermite-tensor method.\n\nArguments:\n\ninterp_x : inteprolation type (Hermite or Radial)\ninterp_y : inteprolation type (Hermite or Radial)\ninterp_z : inteprolation type (Hermite or Radial)\nf        : 3d array containing values at interpolation nodes (Chebyshev or Uniform)\n\nComputing s = ( z ⊗ y ⊗ x) vec(f) (see Sec. 4.1 of the paper)\n\n\n\n\n\n","category":"method"},{"location":"functions/#HermiteGF.interpolate-Tuple{HermiteGF.InterpolationType,HermiteGF.InterpolationType,HermiteGF.InterpolationType,HermiteGF.InterpolationType,Array{Float64,4},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"HermiteGF.interpolate","text":" interpolate( interp_x :: InterpolationType, \n              interp_y :: InterpolationType, \n              interp_z :: InterpolationType, \n              interp_v :: InterpolationType, \n              f  :: Array{Float64,4},\n              xe :: Array{Float64,1},\n              ye :: Array{Float64,1},\n              ze :: Array{Float64,1},\n              ve :: Array{Float64,1})\n\nComputes interpolation of a 4D function via Hermite-tensor method.\n\nArguments:\n\ninterp_x : inteprolation type (Hermite or Radial)\ninterp_y : inteprolation type (Hermite or Radial)\ninterp_z : inteprolation type (Hermite or Radial)\ninterp_v : inteprolation type (Hermite or Radial)\nf        : 4d array containing values at interpolation nodes (Chebyshev or Uniform)\n\nComputing s = (v ⊗ z ⊗ y ⊗ x) vec(f) (see Sec. 4.1 of the paper)\n\n\n\n\n\n","category":"method"},{"location":"functions/#HermiteGF.interpolate-Tuple{HermiteGF.InterpolationType,HermiteGF.InterpolationType,HermiteGF.InterpolationType,HermiteGF.InterpolationType,HermiteGF.InterpolationType,Array{Float64,5},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"HermiteGF.interpolate","text":" interpolate( interp_x :: InterpolationType, \n              interp_y :: InterpolationType, \n              interp_z :: InterpolationType, \n              interp_v :: InterpolationType, \n              interp_w :: InterpolationType, \n              f  :: Array{Float64,4},\n              xe :: Array{Float64,1},\n              ye :: Array{Float64,1},\n              ze :: Array{Float64,1},\n              ve :: Array{Float64,1},\n              we :: Array{Float64,1})\n\nComputes interpolation of a 4D function via Hermite-tensor method.\n\nArguments:\n\ninterp_x : interpolation type (Hermite or Radial)\ninterp_y : interpolation type (Hermite or Radial)\ninterp_z : interpolation type (Hermite or Radial)\ninterp_v : interpolation type (Hermite or Radial)\ninterp_w : interpolation type (Hermite or Radial)\nf        : 5d arrray containing values at interpolation nodes (Chebyshev or Uniform)\n\nExtract the number of collocation and evaluation points in each dimension  Computing s = (w ⊗ v ⊗ z ⊗ y ⊗ x) vec(f) (see Sec. 4.1 of the paper)\n\n\n\n\n\n","category":"method"},{"location":"functions/#HermiteGF.evaluate_hermite-NTuple{4,Any}","page":"Functions","title":"HermiteGF.evaluate_hermite","text":"evaluate_hermite(xk, n, epsilon, gamma)\n\nThis function returns the matrix He of the values of the HermiteGF basis functions. The computation is done via three term recurrence for Hermite functions with an argument gamma*x and then appropriate exponential scaling.\n\nMore details can be found in Section 5.1 of the paper\n\nSTABLE EVALUATION OF GAUSSIAN RADIAL BASIS  FUNCTIONS USING HERMITE POLYNOMIALS  by Anna Yurova and Katharina Kormann.\n\nThis function should be used both for computation of the collocation and evaluation matrices.\n\n\n\n\n\n","category":"method"}]
}
