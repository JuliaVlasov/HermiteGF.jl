<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stable evaluation of Gaussian radial basis functions using Hermite polynomials · HermiteGF.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HermiteGF.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Stable evaluation of Gaussian radial basis functions using Hermite polynomials</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Stable evaluation of Gaussian radial basis functions using Hermite polynomials</a></li></ul><a class="edit-page" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Stable evaluation of Gaussian radial basis functions using Hermite polynomials</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Stable-evaluation-of-Gaussian-radial-basis-functions-using-Hermite-polynomials-1" href="#Stable-evaluation-of-Gaussian-radial-basis-functions-using-Hermite-polynomials-1">Stable evaluation of Gaussian radial basis functions using Hermite polynomials</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.interpolate_1D-NTuple{7,Any}" href="#HermiteGF.interpolate_1D-NTuple{7,Any}"><code>HermiteGF.interpolate_1D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none"> interpolate_1D(function_name, nodes_types, epsilon, N, Ne, interpolation_type, gamma)</code></pre><p>Computes an interpolant of a 1D function via Hermite-tensor method.</p><p>Arguments:</p><ul><li>function<em>name : the name of the tested function.  Options</em>available: &quot;f_3&quot;</li><li>nodes_types : an array of two strings with the spacing of nodes in corresponding directions.             Options available: :Uniform, :Chebyshev</li><li>epsilon : a vector of the values of shape parameters in corresponding directions.         The values cannot be larger than 1!</li><li>N : a vector with the numbers of basis functions in corresponding directions.</li><li>Ne : a vector with the numbers of evaluation points in corresponding directions.</li><li>interpolation_type - a string with the name of preferred basis.                    Options available: :Hermite, :Radial</li></ul><p>gamma - a factor allowing to scale the domain and the function accordingly.</p><p>© Anna Yurova, 2017</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/interpolation1d.jl#L1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.interpolate_2D-NTuple{7,Any}" href="#HermiteGF.interpolate_2D-NTuple{7,Any}"><code>HermiteGF.interpolate_2D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolate_2D(function_name, nodes_types, epsilon, N, Ne, interpolation_type, gamma)</code></pre><p>Computes an interpolant of a 2D function via Hermite-tensor method.</p><p>Arguments:</p><ul><li>function<em>name : the name of the tested function.               Options</em>available: &quot;f_3&quot;</li><li>nodes_types : an array of two strings with the spacing of nodes in corresponding directions.             Options available: &quot;Uniform&quot;, &quot;Chebyshev&quot;</li><li>epsilon : a vector of the values of shape parameters in corresponding directions.         The values cannot be larger than 1!</li><li>N : a vector with the numbers of basis functions in corresponding directions.</li><li>Ne : a vector with the numbers of evaluation points in corresponding directions.</li><li>interpolation_type : a string with the name of preferred basis.                    Options available: &quot;Hermite&quot;, &quot;Radial&quot;</li></ul><p>gamma - a factor allowing to scale the domain and the function accordingly.</p><p>© Anna Yurova, 2017</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/interpolation2d.jl#L1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.evaluate_hermite-NTuple{4,Any}" href="#HermiteGF.evaluate_hermite-NTuple{4,Any}"><code>HermiteGF.evaluate_hermite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function returns the matrix He of the values of the HermiteGF basis functions. The computation is done via three term recurrence for Hermite functions with an argument gamma*x and then appropriate exponential scaling.</p><p>More details can be found in Section 5.1 of the paper</p><p><em>STABLE EVALUATION OF GAUSSIAN RADIAL BASIS  FUNCTIONS USING HERMITE POLYNOMIALS</em>  by Anna Yurova and Katharina Kormann.</p><p>This function should be used both for computation of the collocation and evaluation matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/evaluate_hermite.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.evaluate_radial-NTuple{4,Any}" href="#HermiteGF.evaluate_radial-NTuple{4,Any}"><code>HermiteGF.evaluate_radial</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Evaluate radial basis </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/helper_functions.jl#L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.evaluate_s_1D-Tuple{Any,Any}" href="#HermiteGF.evaluate_s_1D-Tuple{Any,Any}"><code>HermiteGF.evaluate_s_1D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extract the number of collocation and evaluation points</p><p>Computing s =  X_all * vec(F) (see Sec. 4.1 of the paper)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/evaluate_tensor_product.jl#L116-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.evaluate_s_2D-Tuple{Any,Any,Any}" href="#HermiteGF.evaluate_s_2D-Tuple{Any,Any,Any}"><code>HermiteGF.evaluate_s_2D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extract the number of collocation and evaluation points in each dimension</p><p>Computing <code>s = (Y_all ⊗ X_all) vec(F)</code> (see Sec. 4.1 of the paper)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/evaluate_tensor_product.jl#L87-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.evaluate_s_3D-NTuple{4,Any}" href="#HermiteGF.evaluate_s_3D-NTuple{4,Any}"><code>HermiteGF.evaluate_s_3D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extract the number of collocation and evaluation points in each dimension  Computing <code>s = (Z_all ⊗ Y_all ⊗ X_all) vec(F)</code> (see Sec. 4.1 of the paper)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/evaluate_tensor_product.jl#L47-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.evaluate_s_4D-NTuple{5,Any}" href="#HermiteGF.evaluate_s_4D-NTuple{5,Any}"><code>HermiteGF.evaluate_s_4D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>In this file the functions for the serial computing of the interpolated values &#39;s&#39; in 1-4D are implemented. Here the tensor representation of &#39;s&#39; is used (see Sec. 4.1 of the paper).</p><p>Computing s = (W<em>all ⊗ Z</em>all ⊗ Y<em>all ⊗ X</em>all) vec(F) (see Sec. 4.1 of the paper)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/evaluate_tensor_product.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.generate_chebyshev_nodes-Tuple{Any,Any,Any}" href="#HermiteGF.generate_chebyshev_nodes-Tuple{Any,Any,Any}"><code>HermiteGF.generate_chebyshev_nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate chebyshev nodes on the interval [xmin xmax] </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/helper_functions.jl#L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.generate_uniform_nodes-Tuple{Any,Any,Any}" href="#HermiteGF.generate_uniform_nodes-Tuple{Any,Any,Any}"><code>HermiteGF.generate_uniform_nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate uniform nodes on the interval [xmin xmax] </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/helper_functions.jl#L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.interpolate_3D-NTuple{7,Any}" href="#HermiteGF.interpolate_3D-NTuple{7,Any}"><code>HermiteGF.interpolate_3D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolate_3D(function_name, nodes_types, epsilon, N, Ne, interpolation_type, gamma)</code></pre><p>Computes an interpolant of a 3D function via Hermite-tensor method.</p><p>Arguments:</p><ul><li>function<em>name : the name of the tested function.             Options</em>available: &quot;f_3&quot;</li><li>nodes_types : an array of three strings with the spacing of nodes in corresponding directions.           Options available: &quot;Uniform&quot;, &quot;Chebyshev&quot;</li><li>epsilon : a vector of the values of shape parameters in corresponding directions.       The values cannot be larger than 1!</li><li>N : a vector with the numbers of basis functions in corresponding directions.</li><li>Ne : a vector with the numbers of evaluation points in corresponding directions.</li><li>interpolation_type : a string with the name of preferred basis.                  Options available: :Hermite, :Radial</li><li>gamma : a factor allowing to scale the domain and the function accordingly.</li></ul><p>© Anna Yurova, 2017</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/interpolation3d.jl#L1-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.interpolate_4D-NTuple{7,Any}" href="#HermiteGF.interpolate_4D-NTuple{7,Any}"><code>HermiteGF.interpolate_4D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolate_4D(function_name, nodes_types, epsilon, N, Ne, interpolation_type, gamma)</code></pre><p>Computes an interpolant of a 4D function via Hermite-tensor method.</p><p>Arguments:</p><ul><li>function<em>name : the name of the tested function. Options</em>available: &quot;f_3&quot;</li><li>nodes_types : an array of three strings with the spacing of nodes in corresponding directions. Options available: :Uniform, :Chebyshev</li><li>epsilon : a vector of the values of shape parameters in corresponding directions.         The values cannot be larger than 1!</li><li>N : a vector with the numbers of basis functions in corresponding directions.</li><li>Ne : a vector with the numbers of evaluation points in corresponding directions.</li><li>interpolation_type : a string with the name of preferred basis. Options available: :Hermite, :Radial</li></ul><p>gamma - a factor allowing to scale the domain and the function accordingly.</p><p>© Anna Yurova, 2017</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/interpolation4d.jl#L2-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.interpolate_5D-NTuple{7,Any}" href="#HermiteGF.interpolate_5D-NTuple{7,Any}"><code>HermiteGF.interpolate_5D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolate_5D(function_name, nodes_types, epsilon, N, Ne, interpolation_type, gamma)</code></pre><p>Computes an interpolant of a 5D function via Hermite-tensor method.</p><p>Arguments:</p><ul><li>function<em>name : the name of the tested function.  Options</em>available: &quot;f_3&quot;</li><li>nodes_types : an array of three strings with the spacing of nodes in corresponding directions.            Options available: :Uniform, :Chebyshev</li><li>epsilon : a vector of the values of shape parameters in corresponding directions.        The values cannot be larger than 1!</li><li>N : a vector with the numbers of basis functions in corresponding directions.</li><li>Ne : a vector with the numbers of evaluation points in corresponding directions.</li><li>interpolation_type : a string with the name of preferred basis. Options available: :Hermite, :Radial</li><li>gamma - a factor allowing to scale the domain and the function accordingly.</li></ul><p>© Anna Yurova, 2017</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/interpolation5d.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HermiteGF.trapz_1D-Tuple{Any,Any}" href="#HermiteGF.trapz_1D-Tuple{Any,Any}"><code>HermiteGF.trapz_1D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Trapezoidal rule for the uniform grid for 1-5D </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaVlasov/HermiteGF.jl/blob/3ae4c53c78ff4ef81237f7c3eea116b78e42ed0f/src/helper_functions.jl#L40">source</a></section><pre><code class="language-none">interpolation_1D
interpolation_2D
interpolation_3D
interpolation_4D
interpolation_5D</code></pre><footer><hr/></footer></article></body></html>
